<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8" />
    <!-- CSS only -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-iYQeCzEYFbKjA/T2uDLTpkwGzCiq6soy8tYaI1GyVh/UjpbCx/TYkiZhlZB6+fzT" crossorigin="anonymous">
    <!-- JavaScript Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-u1OknCvxWvY5kfmNBILK2hRnQC3Pr17a+RTT6rIHI7NnikvbZlHgTPOOmMi466C8" crossorigin="anonymous"></script>
    <title></title>
</head>
<body>
    <br><br><br><br><br><br>
    <div class="h-100 d-flex align-items-center justify-content-center">
        <div class="card">
            <h1>Audio 2 Text</h1>
            <div class="btn-group btn-group-lg" role="group" aria-label="functions">
                <button id="startRecordingButton" class="btn btn-success">Start recording</button>
                <button id="stopRecordingButton" class="btn btn-danger" hidden>Stop recording</button>
                <button id="playButton" class="btn btn-primary">Play</button>
                <button id="downloadButton" class="btn btn-dark">Download</button>
                <button id="2text" class="btn btn-secondary">2 Text</button>
            </div>
            <div class="card-body">
                <div>
                    <p class="card-text text-white bg-dark" id="ctext"></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        //socket
        var voskserver = "localhost:2700";
        var socket = null;

        function initWS(){
            socket = new WebSocket(`ws://${voskserver}`);
            // socket.binaryType = "arraybuffer";
    
            socket.onopen = (e) => {
                console.log(`Socket opened: ${e}`);
                console.log("sending blob");

                socket.send(`{"config": { "sample_rate": ${sampleRate}}}`);
                socket.send(blob);
                socket.send('{"eof": 1}');
            };
    
            socket.onmessage = (e) => {
                // console.log(`Event data: ${e.data.text}`);
                data = JSON.parse(e.data);
                console.log(data);
                ctext.innerText = `${data.text || data.partial || ""}`;
                // socket.send('{"eof": 1}');
            };
    
            socket.onclose = (e) => {
                if (e.wasClean) {
                    //code & reason
                    console.log(`onclose: ${e}`);
                } else {
                    console.log('[close] Connection died');
                    console.log(e);
                }
            };
    
            socket.onerror = (error) => {
                console.log(`[error] ${error.message}`);
            };
        }

        var dtotext = document.getElementById("2text");
        var ctext = document.getElementById("ctext");

        // ----------------------------------

        var startRecordingButton = document.getElementById("startRecordingButton");
        var stopRecordingButton = document.getElementById("stopRecordingButton");
        var playButton = document.getElementById("playButton");
        var downloadButton = document.getElementById("downloadButton");


        var leftchannel = [];
        var rightchannel = [];
        var recorder = null;
        var recordingLength = 0;
        var volume = null;
        var mediaStream = null;
        var sampleRate = 44100;
        var context = null;
        var blob = null;

        function setDefaults(){
            leftchannel = [];
            rightchannel = [];
            recorder = null;
            recordingLength = 0;
            volume = null;
            mediaStream = null;
            sampleRate = 44100;
            context = null;
            blob = null;
        }

        startRecordingButton.addEventListener("click", ()=> {
            setDefaults();
            startRecordingButton.hidden = true;
            stopRecordingButton.hidden = false;

            // Initialize recorder
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
            navigator.getUserMedia(
            {
                audio: true
            },
            (e)=> {
                console.log("user consent");

                // creates the audio context
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                context = new AudioContext();

                // creates an audio node from the microphone incoming stream
                mediaStream = context.createMediaStreamSource(e);

                // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createScriptProcessor
                // bufferSize: the onaudioprocess event is called when the buffer is full
                var bufferSize = 2048;
                var numberOfInputChannels = 2;
                var numberOfOutputChannels = 2;
                if (context.createScriptProcessor) {
                    recorder = context.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);
                } else {
                    recorder = context.createJavaScriptNode(bufferSize, numberOfInputChannels, numberOfOutputChannels);
                }

                recorder.onaudioprocess = (e)=> {
                    leftchannel.push(new Float32Array(e.inputBuffer.getChannelData(0)));
                    rightchannel.push(new Float32Array(e.inputBuffer.getChannelData(1)));
                    recordingLength += bufferSize;
                }

                // we connect the recorder
                mediaStream.connect(recorder);
                recorder.connect(context.destination);
            },
                        function (e) {
                            console.error(e);
                        });
        });

        stopRecordingButton.addEventListener("click", ()=> {
            stopRecordingButton.hidden = true;
            startRecordingButton.hidden = false;

            // stop recording
            recorder.disconnect(context.destination);
            mediaStream.disconnect(recorder);

            // we flat the left and right channels down
            // Float32Array[] => Float32Array
            var leftBuffer = flattenArray(leftchannel, recordingLength);
            var rightBuffer = flattenArray(rightchannel, recordingLength);
            // we interleave both channels together
            // [left[0],right[0],left[1],right[1],...]
            // var interleaved = interleave(leftBuffer, rightBuffer);
            var interleaved = leftBuffer;

            // we create our wav file
            var buffer = new ArrayBuffer(44 + interleaved.length * 2);
            var view = new DataView(buffer);

            // RIFF chunk descriptor
            writeUTFBytes(view, 0, 'RIFF');
            view.setUint32(4, 44 + interleaved.length * 2, true);
            writeUTFBytes(view, 8, 'WAVE');
            // FMT sub-chunk
            writeUTFBytes(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // chunkSize
            view.setUint16(20, 1, true); // wFormatTag
            // view.setUint16(22, 2, true); // wChannels: stereo (2 channels)
            view.setUint16(22, 1, true); // wChannels: mono (1 channel)
            view.setUint32(24, sampleRate, true); // dwSamplesPerSec
            // view.setUint32(28, sampleRate * 4, true); // dwAvgBytesPerSec
            view.setUint32(28, sampleRate * 2, true); // dwAvgBytesPerSec 16 bit mono
            view.setUint16(32, 4, true); // wBlockAlign
            view.setUint16(34, 16, true); // wBitsPerSample
            // data sub-chunk
            writeUTFBytes(view, 36, 'data');
            view.setUint32(40, interleaved.length * 2, true);

            // write the PCM samples
            var index = 44;
            var volume = 1;
            for (var i = 0; i < interleaved.length; i++) {
                view.setInt16(index, interleaved[i] * (0x7FFF * volume), true);
                index += 2;
            }

            // our final blob
            blob = new Blob([view], { type: 'audio/wav' });

            totext();
        });

        playButton.addEventListener("click", ()=> {
            if (blob == null) {
                return;
            }

            var url = window.URL.createObjectURL(blob);
            var audio = new Audio(url);
            audio.play();
        });

        downloadButton.addEventListener("click", ()=> {
            if (blob == null) {
                return;
            }

            var url = URL.createObjectURL(blob);

            var a = document.createElement("a");
            document.body.appendChild(a);
            a.style = "display: none";
            a.href = url;
            a.download = "sample.wav";
            a.click();
            window.URL.revokeObjectURL(url);
        });

        dtotext.addEventListener("click", ()=> {
            totext();
        });

        function totext(){
            if (blob == null) {
                return;
            }

            if(socket != null){
                console.log("close socket");
                socket.close();
            }
            initWS();
        }

        function flattenArray(channelBuffer, recordingLength) {
            var result = new Float32Array(recordingLength);
            var offset = 0;
            for (var i = 0; i < channelBuffer.length; i++) {
                var buffer = channelBuffer[i];
                result.set(buffer, offset);
                offset += buffer.length;
            }
            return result;
        }

        function interleave(leftChannel, rightChannel) {
            var length = leftChannel.length + rightChannel.length;
            var result = new Float32Array(length);

            var inputIndex = 0;

            for (var index = 0; index < length;) {
                result[index++] = leftChannel[inputIndex];
                result[index++] = rightChannel[inputIndex];
                inputIndex++;
            }
            return result;
        }

        function writeUTFBytes(view, offset, string) {
            for (var i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

    </script>
</body>
</html>